// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ----------------------------------------------------
// Enums
// ----------------------------------------------------

// กำหนด Role ของผู้ใช้งานในระบบ
enum Role {
  ADMIN    // ผู้ดูแลสูงสุด
  SEO_DEV  // เจ้าหน้าที่ SEO
  CUSTOMER // ลูกค้า
}

// กำหนดระดับความยากง่ายของ Keyword (KD)
enum KDLevel {
  HARD
  MEDIUM
  EASY
}

// กำหนดสถานะการชำระเงิน
enum PaymentStatus {
  PENDING
  APPROVED
  REJECTED
}

// ----------------------------------------------------
// Models
// ----------------------------------------------------

// 1. ผู้ใช้งานระบบ (Admin, Seo_dev, Customer Account)
//    - เก็บข้อมูลการล็อกอินและสิทธิ์การเข้าถึงส่วนต่างๆ
model User {
  id                String    @id @default(uuid())
  name              String?   // เก็บชื่อผู้ใช้
  email             String    @unique
  password          String?   // เก็บรหัสผ่าน (optional สำหรับ OAuth providers)
  role              Role      // สิทธิ์การใช้งาน: ADMIN, SEO_DEV, CUSTOMER
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  deletedAt         DateTime? // สำหรับ Soft Delete

  // ความสัมพันธ์
  customerProfile   Customer? @relation("CustomerUser") // ถ้าเป็น CUSTOMER จะมีข้อมูลลูกค้าผูกอยู่
  assignedCustomers Customer[] @relation("SeoDevCustomers") // ถ้าเป็น SEO_DEV จะมีรายชื่อลูกค้าที่ดูแล
  
  // NextAuth.js relations
  accounts Account[]
  sessions Session[]
}

// 2. ข้อมูลลูกค้า (เจ้าของโดเมน)
//    - เป็นโมเดลศูนย์กลางสำหรับเก็บข้อมูลของลูกค้า 1 ราย
//    - ใช้เชื่อมโยงข้อมูล Report ทั้งหมดเข้ากับ User ที่เป็นเจ้าของ
model Customer {
  id     String @id @default(uuid())
  name   String // ชื่อบริษัทลูกค้า เช่น Thanaplus
  domain String @unique // ชื่อโดเมน เช่น WWW.THANAPLUS.COM

  // ความสัมพันธ์กับ User
  userId   String @unique // ID ของ User ที่มี Role เป็น CUSTOMER
  user     User   @relation("CustomerUser", fields: [userId], references: [id])
  seoDevId String? // ID ของ User ที่มี Role เป็น SEO_DEV (อาจจะยังไม่มีผู้ดูแล)
  seoDev   User?     @relation("SeoDevCustomers", fields: [seoDevId], references: [id])

  // ความสัมพันธ์กับข้อมูล Report
  reports         KeywordReport[]     // ลูกค้า 1 คน มีรายงาน Keyword ได้หลายรายการ
  metrics         OverallMetrics?     // ลูกค้า 1 คน มีข้อมูลภาพรวมล่าสุดได้ 1 ชุด
  payments        PaymentProof[]      // ลูกค้า 1 คน มีประวัติการชำระเงินได้หลายครั้ง
  recommendations KeywordRecommend[]  // ลูกค้า 1 คน มี Keyword แนะนำได้หลายรายการ
}

// 3. ข้อมูลสถิติโดยรวมของโดเมน (Overall Metrics)
//    - เก็บข้อมูลภาพรวมที่แสดงอยู่ด้านบนของ Report
model OverallMetrics {
  id              String   @id @default(uuid())
  domainRating    Int      // ค่า Domain Rating (DR)
  healthScore     Int      // ค่า Health Score
  ageInYears      Int      // อายุของโดเมน (Age)
  spamScore       Int      // ค่า Spam Score
  organicTraffic  Float    // ยอด Organic Traffic
  organicKeywords Float    // จำนวน Organic Keywords
  backlinks       Int      // จำนวน Backlinks
  refDomains      Int      // จำนวน Referring Domains
  dateRecorded    DateTime @default(now()) // วันที่บันทึกข้อมูล

  // ความสัมพันธ์: ข้อมูลนี้เป็นของลูกค้าคนไหน
  customerId String   @unique
  customer   Customer @relation(fields: [customerId], references: [id])
}

// 4. รายงาน Keyword และ Position
//    - เก็บข้อมูลในตารางคีย์เวิร์ดที่แสดงใน Report
model KeywordReport {
  id           String   @id @default(uuid())
  keyword      String   // ชื่อ Keyword
  position     Int?     // อันดับ (Position)
  traffic      Int      // ยอด Traffic ที่ได้จากคีย์เวิร์ดนี้
  kd           KDLevel  // ระดับความยาก (KD)
  isTopReport  Boolean  @default(false) // ใช้แยกกลุ่มรายงาน เช่น ตารางบน-ล่าง ในรูป
  dateRecorded DateTime @default(now()) // วันที่บันทึกข้อมูล

  // ความสัมพันธ์: ข้อมูลนี้เป็นของลูกค้าคนไหน
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])
}

// 5. หลักฐานการโอนเงิน
//    - เก็บข้อมูลการอัปโหลดสลิปหรือหลักฐานการชำระเงินของลูกค้า
model PaymentProof {
  id         String        @id @default(uuid())
  uploadUrl  String        // URL ของไฟล์ที่อัปโหลด
  uploadDate DateTime      @default(now())
  status     PaymentStatus @default(PENDING) // สถานะ: รอตรวจสอบ, อนุมัติ, ปฏิเสธ

  // ความสัมพันธ์: ข้อมูลนี้เป็นของลูกค้าคนไหน
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])
}

// 6. Keyword แนะนำสำหรับลูกค้า
//    - เก็บ Keyword ที่ทีม SEO แนะนำให้ลูกค้าทำเพิ่มเติม
model KeywordRecommend {
  id          String   @id @default(uuid())
  keyword     String   // ชื่อ Keyword ที่แนะนำ
  kd          KDLevel? // ระดับความยาก (KD)
  isTopReport Boolean  @default(false) // ใช้แยกกลุ่มรายงาน
  note        String?  @db.Text // หมายเหตุเพิ่มเติม (เช่น เหตุผลที่แนะนำ)
  createdAt   DateTime @default(now())

  // ความสัมพันธ์: ข้อมูลนี้เป็นของลูกค้าคนไหน
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
}

// ----------------------------------------------------
// NextAuth.js Models
// ----------------------------------------------------

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}